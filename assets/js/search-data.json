{
  
    
        "post0": {
            "title": "Title",
            "content": "import time def linear_search(lst, x): start_time = time.perf_counter_ns() # records time (nanoseconds) for i in range(len(lst)): # loops through the entire list if lst[i] == x: # until the x value we are looking for is found end_time = time.perf_counter_ns() # records time again total_time = (end_time - start_time) // 1000 # subtracts last recorded time and first recorded time print(&quot;Found element after {} loops in {} microseconds&quot;.format(i+1, total_time)) # prints the results return print(&quot;Your number was found at&quot;, i) end_time = time.perf_counter_ns() # records the time again total_time = (end_time - start_time) // 1000 # subtracts last recorded time and first recorded time print(&quot;Element not found after {} loops in {} microseconds&quot;.format(len(lst), total_time)) # prints the results return &quot;Your number wasn&#39;t found :(&quot; lst = list(range(1, 10001)) # list with numbers 1-10000 x = 5000 # replace with an integer between 1 and 10000 (I suggest big numbers like 500, 2000, so on) linear_search(lst, x) # runs procedure . import time def binary_search(lt, x): start_time = time.perf_counter_ns() # starts timer low = 0 # sets the lower side mid = 0 # sets mid value high = len(lt) -1 # sets the higher side num_loops = 0 # number of loops the search undergoes to find the x value while low&lt;=high: # Loop ran until mid is reached num_loops += 1 # adds one loop each time process is repeated mid = (low + high) // 2 # takes the lowest and highest possible numbers and divides by 2 and rounds to closest whole # if lt[mid] == x: end_time = time.perf_counter_ns() # records time total_time = (end_time - start_time) // 1000 # time in microseconds print(&quot;Element found after {} loops in {} microseconds&quot;.format(num_loops, total_time)) # prints the results return mid # returns the index value elif lt[mid] &gt; x: # if mid was higher than x value, then sets new highest value as mid -1 high = mid -1 elif lt[mid] &lt; x: low = mid + 1 # if mid was lower than x, sets the new low as mid + 1 end_time = time.perf_counter_ns() total_time = (end_time - start_time) // 1000 print(&quot;Element not found after {} loops in {} microseconds&quot;.format(num_loops, total_time)) # prints the results return &quot;Your number wasn&#39;t found :(&quot; lt = list(range(1, 10001)) # list with numbers 1-10000 x = 149 # replace with an integer between 1 and 10000 (I suggest big numbers like 500, 2000, so on) binary_search(lt, x) # runs procedure .",
            "url": "https://mmaxwu.github.io/Tri2-GroupFastpages/2022/12/13/dd-test.html",
            "relUrl": "/2022/12/13/dd-test.html",
            "date": " • Dec 13, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Unit 3 Sections 17-18",
            "content": "Do Now!!! . Set up your notebook by either wgetting the lesson or tracking it by your own (We would recommend wgetting since there are some fill in the blanks!) | . 3.17: Algorithm Efficiency . Purpose: . 3.18: Undecidable Problems . Purpose: . The purpose of this lesson is to introduce students to the concept of undecidable problems in computer science and to explain why these problems are important. . Key vocabulary: . Decision problem | Decidable problem | Undecidable problem | . Decision Problem . A decision problem is a problem in computer science and mathematics that can be solved by a yes-no answer, also known as a binary answer. In other words, a decision problem is a problem for which there are only two possible outputs:&quot;yes&quot; or &quot;no&quot;. There are two types of decision problems that Collegeboard goes over: . Decidable Problems | Undecidable Problems | . A __ is a problem in computer science and mathematics for which an algorithm can be created that can always produce a correct answer or solution. In other words, a decidable problem is a problem for which there exists an algorithm that can be used to determine whether a given input is a valid solution or not. . An __ problem is a problem in computer science and mathematics for which it is impossible to create an algorithm that can always provide a correct answer or solution. This means that it is not possible for an algorithm to always determine whether a given input is a valid solution to an undecidable problem. . Decidable Problems . content down here fore Evan . Undecidable Problems . An Example of a Forever Running Code . The code keeps adding 1 to the variable number until number is no longer an integer. However, there is no end to this code, making the computer run forever. There is no halt to the code. . i = 0 number = 1 def integerTest(n): if type(n) == int: return True else: return False while i == 0: number += 1 if integerTest(number) == False: i +=1 print(&quot;Done&quot;) . KeyboardInterrupt Traceback (most recent call last) /home/jishnus/vscode/Tri2-GroupFastpages/_notebooks/2022-12-dd-lesson.ipynb Cell 7 in &lt;cell line: 9&gt;() &lt;a href=&#39;vscode-notebook-cell://wsl%2Bubuntu/home/jishnus/vscode/Tri2-GroupFastpages/_notebooks/2022-12-dd-lesson.ipynb#X10sdnNjb2RlLXJlbW90ZQ%3D%3D?line=8&#39;&gt;9&lt;/a&gt; while i == 0: &lt;a href=&#39;vscode-notebook-cell://wsl%2Bubuntu/home/jishnus/vscode/Tri2-GroupFastpages/_notebooks/2022-12-dd-lesson.ipynb#X10sdnNjb2RlLXJlbW90ZQ%3D%3D?line=9&#39;&gt;10&lt;/a&gt; number += 1 &gt; &lt;a href=&#39;vscode-notebook-cell://wsl%2Bubuntu/home/jishnus/vscode/Tri2-GroupFastpages/_notebooks/2022-12-dd-lesson.ipynb#X10sdnNjb2RlLXJlbW90ZQ%3D%3D?line=10&#39;&gt;11&lt;/a&gt; if integerTest(number) == False: &lt;a href=&#39;vscode-notebook-cell://wsl%2Bubuntu/home/jishnus/vscode/Tri2-GroupFastpages/_notebooks/2022-12-dd-lesson.ipynb#X10sdnNjb2RlLXJlbW90ZQ%3D%3D?line=11&#39;&gt;12&lt;/a&gt; i +=1 &lt;a href=&#39;vscode-notebook-cell://wsl%2Bubuntu/home/jishnus/vscode/Tri2-GroupFastpages/_notebooks/2022-12-dd-lesson.ipynb#X10sdnNjb2RlLXJlbW90ZQ%3D%3D?line=12&#39;&gt;13&lt;/a&gt; print(&#34;Done&#34;) KeyboardInterrupt: . Delete the parentheses later below. . There is __(no way) to write an algorithm to analyze and determine whether this code can run forever or not. . In order to understand this, suppose that an algorithm was able to analyze whether a code halts or not. Let&#39;s call this algorithm HaltCheck. | In the above code, the code __(code runs forever), so HaltCheck returns an output of &quot;no end&quot;. | Then, we add another machine called Opposite which reverses HaltCheck&#39;s output. So, if &quot;no end&quot; is the output of HaltCheck, then the output of Opposite is &quot;halt&quot;. It&#39;s also the same the other way around; if HaltCheck has an output of &quot;halt&quot;, then Opposite has an output of &quot;no end&quot;. | We combine these algorithms into one entire body of code. | Since Opposite is the algorithm at the end, hence giving the ultimate output, notice how it prints &quot;no end&quot; when in fact there is an end(As proved by HaltCheck), and how it also prints &quot;halt&quot; when there is in fact is no end to the code(Also proved by HaltCheck). | . The Halting Problem . The halting problem is an example of an undecidable problem. . 3.17 Homework . Your homework for Algorithmic Efficiency is pretty simple. . Use the 1st code below and graph it (Desmos, TI Inpire Cas, e.t.c) | Label the number of loops done as x and the time (microseconds) to find the index as y | Connect the points | Do the same thing with the 2nd code | Compare the two graphs and explain which one of the two is more efficient and why (min. 2 sentences) | Insert images of the graph either in your blog or on review ticket | import time def linear_search(lst, x): start_time = time.perf_counter_ns() # records time (nanoseconds) for i in range(len(lst)): # loops through the entire list if lst[i] == x: # until the x value we are looking for is found end_time = time.perf_counter_ns() # records time again total_time = (end_time - start_time) // 1000 # subtracts last recorded time and first recorded time print(&quot;Found element after {} loops in {} microseconds&quot;.format(i+1, total_time)) # prints the results return print(&quot;Your number was found at&quot;, i) end_time = time.perf_counter_ns() # records the time again total_time = (end_time - start_time) // 1000 # subtracts last recorded time and first recorded time print(&quot;Element not found after {} loops in {} microseconds&quot;.format(len(lst), total_time)) # prints the results return &quot;Your number wasn&#39;t found :(&quot; lst = list(range(1, 10001)) # list with numbers 1-10000 x = 5000 # replace with an integer between 1 and 10000 (I suggest big numbers like 500, 2000, so on) linear_search(lst, x) # runs procedure . import time def binary_search(lt, x): start_time = time.perf_counter_ns() # starts timer low = 0 # sets the lower side mid = 0 # sets mid value high = len(lt) -1 # sets the higher side num_loops = 0 # number of loops the search undergoes to find the x value while low&lt;=high: # Loop ran until mid is reached num_loops += 1 # adds one loop each time process is repeated mid = (low + high) // 2 # takes the lowest and highest possible numbers and divides by 2 and rounds to closest whole # if lt[mid] == x: end_time = time.perf_counter_ns() # records time total_time = (end_time - start_time) // 1000 # time in microseconds print(&quot;Element found after {} loops in {} microseconds&quot;.format(num_loops, total_time)) # prints the results return mid # returns the index value elif lt[mid] &gt; x: # if mid was higher than x value, then sets new highest value as mid -1 high = mid -1 elif lt[mid] &lt; x: low = mid + 1 # if mid was lower than x, sets the new low as mid + 1 end_time = time.perf_counter_ns() total_time = (end_time - start_time) // 1000 print(&quot;Element not found after {} loops in {} microseconds&quot;.format(num_loops, total_time)) # prints the results return &quot;Your number wasn&#39;t found :(&quot; lt = list(range(1, 10001)) # list with numbers 1-10000 x = 149 # replace with an integer between 1 and 10000 (I suggest big numbers like 500, 2000, so on) binary_search(lt, x) # runs procedure . 3.18 Homework: . Use the Jupyter notebook to write an algorithm that solves a decidable problem. You can use math or whatever else you would like to do. | Write code to get the computer to run forever. Check this example if you need help, but please come up with your own idea. |",
            "url": "https://mmaxwu.github.io/Tri2-GroupFastpages/lessons/2022/12/13/dd-lesson.html",
            "relUrl": "/lessons/2022/12/13/dd-lesson.html",
            "date": " • Dec 13, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "College Board Notes",
          "content": "Notes .",
          "url": "https://mmaxwu.github.io/Tri2-GroupFastpages/CollegeboardNotes/",
          "relUrl": "/CollegeboardNotes/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "About Us",
          "content": "Fastpages for Max, Jishnu, Alan, Evan .",
          "url": "https://mmaxwu.github.io/Tri2-GroupFastpages/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://mmaxwu.github.io/Tri2-GroupFastpages/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}